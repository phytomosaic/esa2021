---
title: "ESA 2021"
output:
  learnr::tutorial:
    css: css/custom.css
    fig_width: 5.5
    fig_height: 5.5
    # ace_theme: "cobalt"
    progressive: false
    toc: true
    toc_depth: 6
    toc_float:
      collapsed: false
      smooth_scroll: false
runtime: shiny_prerendered
description: "Community analysis of species, traits, phylogenies, and responses to environment."
---

```{r begin, include=FALSE, eval=TRUE}
require(learnr)
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, include = TRUE, out.width="99%")
knitr::knit_theme$set("rootwater")
learnr::tutorial_options(exercise.timelimit = 10, exercise.eval = FALSE, exercise.completion = TRUE)
```

```{r setup, include=FALSE}
### HIDDEN ###
require(vegan)
require(labdsv)
require(ade4)
require(ecodist)
require(optpart)
require(vegclust)
require(ape)
require(picante)
require(mgcv)
load('veg.rda')  # assumed to be in your working dir
xy  <- veg$xy    # spatial
spe <- veg$spe   # species
env <- veg$env   # environment
tra <- veg$tra   # traits
phy <- veg$phy   # phylogeny
rm(veg)          # cleanup
spe <- data.frame(log10(spe + 1))
env <- data.frame(decostand(scale(env, center=F), 'range'))
tra <- data.frame(decostand(tra, 'range'))
d   <- vegdist(spe, method='bray', binary=T)
D   <- stepacross(d, 'shortest', toolong=1, trace=F)
cl  <- vegclustdist(D, mobileMemb=7, method='FCM', m=1.2, nstart=5)
grp <- defuzzify(cl, 'max')[[2]]
m1  <- metaMDS(D, k=2, try=200, trymax=500, trace=0)  # NMS
m2  <- cmdscale(D, k=2, add=T)               # PCoA
m3  <- prcomp(spe)                           # PCA
env$grp <- cut(env$k, quantile(env$k, probs=seq(0,1,by=0.25)), include.lowest=T,
               labels=c('lo','med','hi','veryhi')) # group memberships for K
`get_palette` <- function() {
  pal <- c('#414487E6','#404688E6','#3F4889E6','#3E4989E6','#3E4C8AE6',
           '#3D4E8AE6','#3C508BE6','#3B528BE6','#3A548CE6','#39558CE6',
           '#38588CE6','#375A8CE6','#365C8DE6','#355E8DE6','#35608DE6',
           '#34618DE6','#33638DE6','#32658EE6','#31678EE6','#30698EE6',
           '#306A8EE6','#2F6C8EE6','#2E6E8EE6','#2D708EE6','#2C718EE6',
           '#2C738EE6','#2B748EE6','#2A768EE6','#2A788EE6','#297A8EE6',
           '#287C8EE6','#287D8EE6','#277F8EE6','#26818EE6','#26828EE6',
           '#25848EE6','#24868EE6','#24878EE6','#23898EE6','#228B8DE6',
           '#228D8DE6','#218F8DE6','#21908CE6','#20928CE6','#20938CE6',
           '#1F958BE6','#1F978BE6','#1F998AE6','#1F9A8AE6','#1E9C89E6',
           '#1F9E89E6','#1FA088E6','#1FA187E6','#20A386E6','#20A486E6',
           '#21A685E6','#22A884E6','#24AA83E6','#25AC82E6','#26AD81E6',
           '#28AE80E6','#2AB07FE6','#2DB27DE6','#2FB47CE6','#32B67AE6',
           '#34B679E6','#37B878E6','#3ABA76E6','#3DBC74E6','#40BD72E6',
           '#43BF71E6','#47C06FE6','#4AC16DE6','#4EC36BE6','#52C569E6',
           '#55C668E6','#59C864E6','#5DC863E6','#60CA60E6','#65CB5EE6',
           '#68CD5BE6','#6DCD59E6','#71CF57E6','#75D054E6','#7AD151E6',
           '#7FD34EE6','#83D44CE6','#87D549E6','#8CD646E6','#90D743E6',
           '#95D840E6','#9AD93CE6','#9FDA3AE6','#A3DA37E6','#A8DB34E6',
           '#ADDC30E6','#B2DD2DE6','#B7DE2AE6','#BBDF27E6')
  return(pal)
}
`colvec` <- function(x) {
  pal <- get_palette()
  return(pal[cut(as.numeric(x), breaks=length(pal), include.lowest=TRUE)])
}
### HIDDEN ###
```


<!-- --------------------------------------------- -->


## Overview

#### __*Why are we here today?*__ {#why-here}

This course demonstrates **the practice of ecological community analysis in R**. Our goal is to link biological reality with corresponding conceptual and mathematical models.  We borrow and apply concepts from ecology, statistics and computer science, but do not get too bogged down in theoretical details.  This short course aims to be an [axe handle](https://www.poetryfoundation.org/poems/57150/axe-handles){target="_blank"} --- carve and shape it to your own practice.

### Learning outcomes
List here.

### Assumptions

We assume you have a basic familiarity with R.  If not, please peruse [here](http://ecology.msu.montana.edu/labdsv/R/labs/R_ecology.html).  At the least, you should be able to assign an object, distinguish between different objects (vector, matrix, data.frame, etc.), and index rows/columns of a matrix or data.frame.

We assume you have familiarity with basic statistics (population vs sample; mean, SD, SE, CI; simple linear models), and have at least dabbled in linear algebra (matrices; linear combinations), and perhaps become suspicious that calculus may indeed exist.  If not, you could brush up on [matrices](https://courses.lumenlearning.com/boundless-algebra/chapter/introduction-to-matrices/).

### Software installation

Packages contain supplemental functions you will need.  They are supplemental beyond "base" R.  Ordinarily you would open R and install required packages as follows (but these dependencies should have automatically installed when you first installed this tutorial). 

```{r install-pkgs, exercise=FALSE, eval=FALSE}
install.packages('vegan')     # community ecology
install.packages('labdsv')    # community ecology
install.packages('ade4')      # community ecology
install.packages('ecodist')   # community ecology
install.packages('optpart')   # clustering
install.packages('vegclust')  # clustering
install.packages('ape')       # phylogenetics
install.packages('picante')   # phylogenetics
install.packages('mgcv')      # nonlinear regression
```

### Load packages

To use functions provided by packages, load them into your R environment.  Again, this has already been done for you in the tutorial.

```{r load-pkgs, exercise=FALSE, eval=FALSE}
require(vegan)
require(labdsv)
require(ade4)
require(ecodist)
require(optpart)
require(vegclust)
require(ape)
require(picante)
require(mgcv)
```

### Useful functions to explore

Base R already contains lots of useful functions.  This list has a few basic functions: 

```
ls()
dim(spe)
NROW(spe)
NCOL(spe)
str(spe)
head(spe)
names(spe)
x <- spe[,11]
x <- spe[,'bolboschoenus_maritimus']
hist(x)
plot(x)
rm(x)
```
From the list above, copy-and-paste some commands into the code box below, and help describe a dataset called `spe`.  What is inside that object?  What size is it?

```{r blank-to-try-functions, exercise=TRUE}

```

### Define objects and functions

We've already said that you can use functions from base R or from other packages.  But you can also "roll your own"!  Functions take the generic form `f <- function(x) { x }`.  For example:

```{r define-functions, exercise=TRUE}
# function to pick an item from the vector by position
`item_picker` <- function(x, pos = NULL) {
  x[pos]
}
z <- 1:19               # assign a sequence of numbers to object `z`
item_picker(z, pos = 5) # pick the fifth element of `z`
```

## Data

#### __*Where did this dataset originate?*__ {#data-origin}

### Mafragh, Algeria vegetation data

We will use one core dataset throughout this tutorial. The `veg` dataset gives information about spatial coordinates, species, environment, traits, and phylogeny for plants on the Mafragh coastal plain in North Africa.  Specifically, `veg` is a list containing five items:

* `xy` 97 observations of 2 spatial coordinates
* `spe` 97 observations of 56 plant species
* `env` 97 observations of 11 soil environmental variables
* `tra` 12 traits for 56 plant species
* `phy` phylogeny for 56 plant species

### Load data

A common task in R is to read from CSV files, e.g., `x <- read.csv('path/to/file.csv')`, but here we will load data that's already in R format.

```{r data-load, exercise=FALSE, eval=FALSE}
load('veg.rda')  # assumed to be in your working dir
xy  <- veg$xy    # spatial
spe <- veg$spe   # species
env <- veg$env   # environment
tra <- veg$tra   # traits
phy <- veg$phy   # phylogeny
rm(veg)          # cleanup
ls()             # objects now in this environment
```

### Study area description

The Mafragh plain is in El Tarf Province of far northeast Algeria (36.84704$^{\circ}$, 7.945$^{\circ}$).  According to documentation in R package `ade4`:

> This marshy coastal plain is a geomorphological feature, east of Port of Annaba, limited to the north by the Mediterranean Sea and a dune cordon, to the south by clay-sandstone Numidian massifs, to the west by a wadi and to East by an irrigated perimeter. It covers 15,000 ha of which 10,000 form the area of study.

Potential human pressures include grazing, irrigation and salination, plowing, and housing development.  Its Köppen climate type is "Csa: Hot-summer Mediterranean climate".

### History of the Mafragh dataset

The data originate from the field studies of Prof. Gérard de Bélair of Annaba in northeast Algeria.  Born in France, de Bélair became a missionary priest in 1969 shortly after Algeria's independence, then an agronomist during the Agrarian Revolution, then a botanist, then professor, then conservationist (according to his [lay](http://gdebelair.com/itineraire.html) and [clergy](https://www.visages-diocese-autun.fr/visage/de-belair-gerard/) accounts).  As of 2021, he continues to actively publish on the vegetation of northern Algeria.  

We should recognize the colonialist legacies that brought us here.  France controlled Algeria from 1830 until its independence in 1962.  Prior to that, Algeria was occupied by Ottoman Turks, Spaniards, Arab Muslims, Berber/Amazigh, Romans, Phoenicians, and prehistoric occupants dating to at least 1.8 million years ago.  We may speculate that the region's vegetation and cultural histories have been closely intertwined.  

The data were included in early versions of the `ade4` software (Dray and Dufour 2007) which itself has its roots at Université Lyon 1, France.  The present data are lightly modified from Appendix S4 of Pavoine et al. (2011), who also added a phylogeny.

### Key references

de Bélair, G. 1981. Biogéographie et aménagement de la Plaine de la Mafragh (Annaba - Algérie) [Biogeography and development of the Mafragh Plain (Annaba, Algeria)]. Dissertation, Université Paul Valéry, Montpellier. http://www.sudoc.fr/00871262X  

de Bélair, G. 1990. Structure, fonctionnement et perspectives de gestion de quatre écocomplexes lacustres et marécageux (El Kala, Est-Algérien) [Structure, function and management perspectives of four lake and marsh eco-complexes (El Kala, East Algeria)]. Dissertation, Université des sciences et techniques de Montpellier 2. http://www.sudoc.fr/007729197  

de Bélair, G. and M. Bencheikh-Lehocine. 1987. Composition et déterminisme de la végétation d'une plaine côtière marécageuse: La Mafragh (Annaba, Algérie) [Composition and determinism of the vegetation of a marshy coastal plain: La Mafragh (Annaba, Algeria)]. Bulletin d'Ecologie, 18(4): 393–407.  

Dray, S. and A. Dufour. 2007. The `ade4` package: implementing the duality diagram for ecologists. Journal of Statistical Software 22(4): 1-20. [doi:10.18637/jss.v022.i04](https://doi.org/10.18637/jss.v022.i04)  

Pavoine, S., Vela, E., Gachet, S., de Bélair, G. and Bonsall, M. B. 2011. Linking patterns in phylogeny, traits, abiotic variables and space: a novel approach to linking environmental filtering and plant community assembly. Journal of Ecology 99: 165–175. [doi:10.1111/j.1365-2745.2010.01743.x](https://doi.org/10.1111/j.1365-2745.2010.01743.x)  


<!-- --------------------------------------------- -->


## Pre-analysis

#### __*How do I get my data into shape for analysis?*__

### Check data structure

A first step in exploring ecological data is to examine its structure.  Run some of this code, one at a time:

```
str(spe)     # community (species) abundance matrix
str(env)     # environmental matrix
str(tra)     # traits matrix
str(phy, 1)  # phylogeny
str(xy)      # spatial coordinates
```

```{r structure, exercise=TRUE}

### run code here

```

### Find and replace troublesome values

```{r replace-pesky, exercise=TRUE}
# create example matrix with some pesky values
s <- spe
s[5,2] <- NA
s[6,4] <- (-999)

# index the row and column of any NA values
which(is.na(s), arr.ind=TRUE)

# index the row and column of any negative values
which(s < 0, arr.ind=TRUE)

# replace value by logical test
s[is.na(s)] <- 777
head(s)
rm(s)
```

### Data transformations


```{r transformations-setup, exercise=FALSE, include=FALSE}
### HIDDEN
load('veg.rda')  # assumed to be in your working dir
spe <- veg$spe   # species
env <- veg$env   # environment
tra <- veg$tra   # traits
rm(veg)          # cleanup
### HIDDEN
```

```{r transformations, exercise=TRUE, exercise.setup='transformations-setup'}
### basic transformations
spe <- data.frame(log10(spe + 1))
env <- data.frame(vegan::decostand(scale(env, center=F), 'range'))
tra <- data.frame(vegan::decostand(tra, 'range'))

head(env)
head(tra)
```

### Abundances to presence/absence

```{r presence-absence, exercise=TRUE}
s <- (spe > 0) * 1  # from numeric to 0/1
s[1:5, 1:7]
range(s)
rm(s)
```


### Outliers

A quick way to search for *multivariate* outliers is to use the distance/dissimilarity matrix.  An "outlier" is the sample unit(s) which exceed a defined number of SDs away from the grand mean (i.e., a large _z_-score).

```{r}
`outliers` <- function (x, mult=2, method='bray') {
  d <- as.matrix(vegan::vegdist(x, method=method, binary=F, diag=T, upper=T))
  diag(d) <- as.numeric(1)     # avoid zero-multiplication
  m       <- apply(d, 2, mean) # site means
  z       <- scale(m)          # z-scores
  data.frame(mean_dist = m, z = z, is_outlier = abs(z) >= mult)
}
### try it
data(dune, package='vegan')
spe <- rbind(runif(ncol(dune),0,1000), dune) # add an outlier row
head(outliers(spe, mult=2), 7)
```


### Test validity of species matrix

```{r mx-valid, exercise=TRUE}
!anyNA(spe)                     # expect TRUE, no missing values
all(rowSums(spe, na.rm=T) != 0) # expect TRUE, no empty sites
all(colSums(spe, na.rm=T) != 0) # expect TRUE, no empty species
```


### Visualize data

First, define a color palette.

```{r viz-color, exercise=TRUE}
u <- get_palette()
```

Let's map the spatial coordinates.

```{r viz-xy, exercise=TRUE, exercise.setup='viz-color'}
# spatial
plot(xy, pch=19, col='#00000050', xlab='Eastness', ylab='Northness')
```

Plot the species abundance matrix as a heatmap.

```{r viz-spe, exercise=TRUE, exercise.setup='viz-color'}
# species
vegan::tabasco(spe, col=u)
```

Plot the soils (environmental) matrix as a heatmap.

```{r viz-env, exercise=TRUE, exercise.setup='viz-color'}
# environment
vegan::tabasco(env, col=u)
```

Plot the traits matrix as a heatmap.

```{r viz-tra, exercise=TRUE, exercise.setup='viz-color'}
# traits
vegan::tabasco(tra, col=u)
```

Plot the phylogenetic tree.

```{r viz-phy, exercise=TRUE}
# phylogeny
plot(phy, cex=0.6, no.margin=TRUE)
```


### Key references


<!-- --------------------------------------------- -->


## Diversity measures

#### *How diverse is this site? collection of sites? region?*

Let's get an overview of the "diversity" of our sites and study area.  Diversity can encompass any sort of variation, e.g., taxonomic, trait, or phylogenetic.  Here we assume that `spe` is a species abundance matrix where rows = sites, columns = taxa, and values must not be negative or missing.

### Species diversity

```{r div-gam, exercise=TRUE}
### Gamma (regional) diversity
gamma <- sum(colSums(spe) > 0)
gamma
```
```{r div-alf, exercise=TRUE}
### Alpha (per-site) diversity
alpha <- rowSums(spe > 0)
alpha    # within-site
avgalpha <- mean(rowSums(spe > 0))
avgalpha # average within-site
```
```{r div-bet, exercise=TRUE, exercise.setup = 'div-alf'}
### Beta (among-site) diversity (Whittaker's)
beta <- gamma / avgalpha - 1
beta
```
```{r div-propz, exercise=TRUE}
### Beta-diversity: proportion of zeros in matrix
propzero <- sum(spe == 0) / prod(dim(spe))
propzero

### Beta-diversity: Dust Bunny Index of McCune and Root (2015)
dbi <- 1 - mean(as.matrix(vegan::decostand(spe, method = 'max')))
dbi
```
```{r div-noshare, exercise=TRUE}
### Beta-diversity: how many site-pairs share no species in common?
z <- vegan::no.shared(spe)
propnoshare <- sum(z) / length(z)
propnoshare
```


### Trait diversity

Here.


### Phylogenetic diversity

Here.


### Key references

McCune, B., and H.T. Root. 2015. Origin of the dust bunny distribution in ecological community data. _Plant Ecology_ 216(5): 645-656.

<!-- --------------------------------------------- -->


## Dissimilarities

#### *How related are community compositions among any two sites?*

Dissimilarities among sites help us position sites along gradients, organize them into clusters, or distinguish differences among groups of sites.  

### Dissimilarity matrix for species
Create a pairwise dissimilarity matrix `d` based on shared and unshared species among sites.  Euclidean distances are seldom useful for species abundance data, here we use the more preferable Bray-Curtis (Sørensen) dissimilarity.

```{r dissimilarities, exercise=TRUE}
d <- vegdist(spe, method='bray', binary=T)
str(d)
```

### Stepacross adjustment
Sometimes a pair of sites are "maximally dissimilar": they share no species at all, so pairwise dissimilarity is impossible to quantify.  Stepacross adjustment solves this by relating intermediate site(s) that share at least some species in common with the "no-share" sites.

```{r stepacross, exercise=TRUE}
D <- stepacross(d, 'shortest', toolong = 1)
plot(d, D, xlab = 'Original', ylab = 'Stepacross')
```


### Distance matrix for environment
Create a pairwise distance matrix `E` based on Euclidean environmental distances among sites.
```{r dist-env, exercise=TRUE}
E <- vegdist(env, method='bray', binary=T)
str(E)
```


### Key references


<!-- --------------------------------------------- -->


## Ordination (unconstrained)

#### *How best to order sites by dissimilarities of community compositions?*

Order sites according to community compositions.  Ordination distances indicate compositional dissimilarities.  Nearby points are more compositionally similar than distant points.

```{r ordination, exercise=TRUE, exercise.timelimit=120}
# three kinds of ordination
m1 <- metaMDS(D, k=2, try=200, trymax=500)  # NMS
m2 <- cmdscale(D, k=2, add=T)               # PCoA
m3 <- prcomp(spe)                           # PCA
```

Plotting the ordinations.

```{r ordination-plotting-01, exercise=TRUE}
# color vector for plotting
u <- get_palette()
u <- u[1:nrow(spe)]

# compare three kinds of ordination
par(mfrow=c(1,3), bty='l', las=1)
plot(m1$points, type='n', xlab='NMDS1', ylab='NMDS2')
text(m1$points, rownames(m1$points),cex=.8, col=u)
plot(m2$points, type='n', xlab='PCoA1', ylab='PCoA2')
text(m2$points, rownames(m2$points),cex=.8, col=u)
plot(m3$x, type='n', xlab='PCA1', ylab='PCA2')
text(m3$x, rownames(m3$x),cex=.8, col=u)
par(mfrow=c(1,1))
```

Ordination goodness-of-fit
```{r ordination-goodness-of-fit, exercise=TRUE}
# fit btwn ordination distances vs original species dissimilarities
cor(dist(m1$points), D, method='kendall')
cor(dist(m2$points), D, method='kendall')
cor(dist(m3$x), D, method='kendall')
# NMS is almost always the best choice -- it minimizes stress

# fit btwn environmental distances vs original species dissimilarities
pc <- prcomp(env[,sapply(env, is.numeric)], scale=T) # PCA of enviro
pc <- scores(pc, display='sites', choices=1:2)       # PCA scores
eD <- vegdist(pc, method='euc')  # Euclidean distances of scores
mantel(D, eD)            # fit = Mantel statistic r
protest(m1$points, pc)   # fit = correlation in Procrustes rotation
rm(pc, eD, u)
```

Plotting again. 

```{r ordination-plotting-02, exercise=TRUE}
# overlay gradients using point colors
par(mfrow=c(1,3), bty='l', las=1)
plot(scores(m1), pch=16, col=colvec(env$k))
plot(scores(m1), pch=16, col=colvec(env$k2o))
plot(scores(m1), pch=16, col=colvec(env$sand))
par(mfrow=c(1,1))

# overlay gradients by fitting a GAM surface
f1 <- ordisurf(m1 ~ env$k, plot = FALSE)
plot(scores(m1), pch = 16, col = colvec(env$k))
plot(f1, add = TRUE, col = 1, lwd = 2)
```

Dimensionality selection. 

```{r dimensionality-selection, exercise=TRUE}
# define screeplot function, running NMS for varying dimensions
`scree_nms` <- function(kk = 5, ...) {
  stress <- rep(NA, kk)
  for (i in 1:kk) {
    cat('calculating', i, 'of', kk, 'dimensions...\n')
    m <- metaMDS(D, k=i, try=200, trymax=500, trace=0)
    stress[i] <- m$stress
  }
  plot(1:kk, stress, main='', xlab='Dimension', ylab='Stress',
       ylim=c(0, max(stress)*1.05), pch=16, las=1, bty='l')
  lines(1:kk, stress)
  abline(0.20, 0, col='red', lty = 2)
  abline(0.15, 0, col='gold', lty = 2)
  abline(0.10, 0, col='green', lty = 2)
  data.matrix(stress)
}
scree <- scree_nms(kk = 5)  # 2 dimensions seems ok...
scree
```

### Key references

Kruskal, J.B. 1964. Multidimensional scaling by optimizing goodness-of-fit to a nonmetric hypothesis. _Psychometrika_ 29: 1-28.

<!-- --------------------------------------------- -->


## Ordination (constrained)

#### *How best to order sites by dissimilarities of community compositions,* after *accounting for measured environmental variables?*

```{r ord-constrained, exercise=TRUE}
# dbRDA: distance-based RDA
m1 <- dbrda(D ~ k + sand + conductivity, 
            data = env, 
            comm = spe, 
            add = 'lingoes')

# RDA: redundancy analysis
m2 <- rda(spe ~ k + sand + conductivity, data=env)

# CCA: constrained correspondence analysis
m3 <- cca(spe ~ k + sand + conductivity, data=env)

# FSO: fuzzy set ordination
m4 <- fso::fso(...)

# summaries
m1
m2
m3
m4

# compare four kinds of ordination
u <- colvec(env$k)                # color vector
par(mfrow=c(2,2), bty='l', las=1)
plot(m1)
points(m1, pch=16, col=u)
plot(m2)
points(m2, pch=16, col=u)
plot(m3)
points(m3, pch=16, col=u)
plot(m4)
points(m4, pch=16, col=u)
```

### Key references


<!-- --------------------------------------------- -->


## Group clustering

#### *How to group sites according to dissimilarity of community compositions?*


### Hierarchical: Ward's clustering

```{r wards, exercise=TRUE, fig.asp=0.50}
k   <- 7                           # number of groups is specified in advance
cl  <- hclust(D, method='ward.D2') # clustering solution
grp <- cutree(cl, k)               # group memberships

# plot the dendrogram, and plot the groups onto an NMS ordination
u <- colvec(grp)
par(mfrow=c(1,2), bty='l', las=1, oma=c(0,0,0,0), mar=c(3,3,0.5,0.5))
plot(cl, cex=0.5, main='')
rect.hclust(cl, k, border=unique(u))
plot(scores(m1), pch=16, cex=0.7, col=u)
ordicluster(m1, cl, prune=k, lwd=0.5, col=u)
```


### Non-hierarchical: fuzzy clustering

It may be useful to define groups based on _fuzzy_ rather than _crisp_ partitions.  Do a few kinds of fuzzy clustering:

```{r fuzz-01, exercise=TRUE, exercise.timelimit = 20}
ns   <- 1       # number of random starts (increase for real analyses!)
k    <- 7       # number of groups is specified in advance
# fuzzy c-means
cl   <- vegclustdist(D, mobileMemb=k, method='FCM', m=1.2, nstart=ns)
# fuzzy c-means with a noise cluster
cl_a <- vegclustdist(D, mobileMemb=k, method='NC', m=1.2, dnoise=0.8, nstart=ns)
# fuzzy c-medoids
cl_b <- vegclustdist(D, mobileMemb=k, method='FCMdd', m=1.2, nstart=ns)
# crisp k-means
cl_c <- vegclustdist(D, mobileMemb=k, method='KM', nstart=ns)

# how well do the other methods agree with fuzzy c-means?
concordance(cl, cl_a)
concordance(cl, cl_b)
concordance(cl, cl_c)

```

Let's examine group memberships `grp` from the fuzzy clustering.  While memberships are fuzzy, we can ask for a _crisp_ membership based on a threshold or else the maximum fuzzy membership.

```{r fuzz-02, exercise=TRUE}
head(round(cl$memb, 2))               # fuzzy membership
(grp <- defuzzify(cl, 'cut', alpha=0.8)[[2]]) # crisp, at threshold (incl NAs)
(grp <- defuzzify(cl, 'max')[[2]])    # crisp membership, at max membership
table(grp, useNA='always')            # tally points per group
```

Also examine the group characteristics:

```{r fuzz-03, exercise=TRUE}
### examine group characteristics
cl$size                               # group size (sum of fuzzy memberships)
cl$withinss                           # group sums-of-squares
round(ctr <- clustcentroid(D, grp),3) # group centroids
(medoids  <- clustmedoid(spe, grp))   # *indices* of group medoids
clustvar(D, grp)                      # within-group variance
clustvar(D)                           # pooled among-group variance
as.dist(D_ctr <- as.matrix(interclustdist(D, grp))) # dissim among centroids
as.dist(D_med <- as.matrix(D)[medoids,medoids])     # dissim among medoids
```

How are species represented per group? Examine species frequency (constancy) per group:

```{r fuzz-04, exercise=TRUE}
con <- clustconst(spe, memb=as.memb(grp))
tabasco(t(con), col=get_palette())    # constancy per group
summary(con, mode='all')              # constancy per group
summary(con, mode='cluster', 'M1')    # examine one particular group
```

How to choose a valid number of groups? Systematically vary _k_, then evaluate. PCN = normalized partition coefficient (higher is better). PEN = normalized partition entropy (lower is better).

```{r fuzz-05, exercise=TRUE}
### systematically vary k from 3 to 9, then evaluate
cl_k <- random.vegclustdist(D, cmin=3, cmax=9, nstart=3, method='FCM', m=1.2)
sapply(seq_along(cl_k), function(i) vegclustIndex(cl_k[[i]])) # evaluate!
```

You may wish to add new sites to an existing classification.  For example, imagine we fit a model using "western" sites, and now must assign values for the "eastern" sites.

```{r fuzz-06, exercise=TRUE, fig.asp=0.667}
### assign *new* sites to an *existing* classification ---
i    <- (xy$x < 220)                  # split the dataset, based on location
west <- spe[i,]                       # old calibration data = west
west <- west[,colSums(west) > 0]      # exclude zero-sum species
east <- spe[!i,]                      # new evaluation data = east
east <- east[,colSums(east) > 0]      # exclude zero-sum species
k    <- 7                             # number of groups specified in advance
(grp_west <- cutree(hclust(vegdist(west), 'ward.D2'), k)) # *existing* model
cl_west   <- as.vegclust(vegdist(west), grp_west) # convert to vegclust object
m  <- conformveg(west, east)                      # merge datasets
DD <- as.matrix(vegdist(rbind(m$x,m$y)))          # ALL dissimilarities
DD <- DD[(NROW(west)+1):NCOL(DD), 1:NROW(west)]   # rows = new, cols = old
cl_east <- vegclass(cl_west, DD)      # assign new points given existing model
grp_west <- defuzzify(cl_west)[[2]]   # memberships of *old* points
grp_east <- defuzzify(cl_east)[[2]]   # memberships of *new* points
grp <- c(grp_west,grp_east)
par(mfrow=c(1,2), oma=c(0,0,0,0), mar=c(2,2,1,0))
plot(xy, col=i+1, pch=16)             # map east/west locations
plot(xy, col=colvec(grp), pch=16)     # map group memberships
text(xy, grp)                         # identify group membership
legend('bottomleft', leg=1:k, fill=unique(colvec(grp)), title='Group', cex=0.7)
```

### Optimal partitioning
```r 
# optimal partitioning
require(optpart)

```


### Cluster evaluation and goodness-of-fit


### Key references


<!-- --------------------------------------------- -->


## Group differences

#### *Do community compositions significantly differ among groups?*

Let's assume PERMANOVA is the best choice for comparing groups in multivariate space. Other methods (ANOSIM, MRPP) exist, but PERMANOVA usually has better power and false-detection rates, even when groups may have different dispersions (Anderson and Walsh 2013) among other operational advantages.

```{r grp-define, exercise=TRUE}
### define and visualize four groups
brk     <- quantile(env$k, probs=seq(0,1,by=0.25))   # define breaks
env$grp <- cut(env$k, brk, include.lowest=T,
               labels=c('lo','med','hi','veryhi'))   # group memberships
table(env$grp, useNA='always')                       # group tally
tapply(env$k, INDEX = env$grp, FUN = mean)           # group means
plot(m1$points, pch=NA)                              # visualize on the NMS
text(m1$points, labels=env$grp, col=as.numeric(env$grp)) # group memberships
ordispider(m1, groups=env$grp, col=1:4)              # group centroids 
```

### Test for difference in community compositions

PERMANOVA tests for differences in multivariate centroid, _in the space of the chosen dissimilarity measure_.  Recall that matrix `D` was our matrix of pairwise Bray-Curtis dissimilarities.

```{r grp-diff-permanova, exercise=TRUE}
### permanova: test for differences in multivariate *centroid*
a1 <- adonis(D ~ env$grp, permu=999)
a1
```

How do we interpret this result?  Based on Bray-Curtis dissimilarities, four groups defined by soil potassium significantly differed in community compositions (PERMANOVA pseudo-_F_ = 10.2, permutational _p_ = 0.001, _R_^2^ = 0.25).  The NMS ordination helps us see that this is largely driven by the "veryhi" group.  Which you can test formally by repeating PERMANOVA for pairwise multiple comparisons.

### Test for homogeneity of community compositions

A related test, PERMDISP, tests for differences in multivariate dispersion, _in the space of the chosen dissimilarity measure_. This is interpreted as a test of among-group homogeneity of community compositions, i.e., beta-diversity.  Conveniently, we can ask for pairwise multiple comparisons.

```{r grp-diff-permdisp, exercise=TRUE}
### permdisp: test for differences in multivariate *dispersion*
b1 <- betadisper(D, env$grp)
b1
permutest(b1, pairwise=TRUE, permu=999)
boxplot(b1)
```

How do we interpret this?  Based on Principal Coordinates reduction of original Bray-Curtis dissimilarities, the four groups defined by soil potassium significantly differed in homogeneity of community compositions (PERMDISP _F_ = 7.98, permutational _p_ = 0.001).  This was due to the "veryhi" potassium group having significantly lower dispersion (lower beta-diversity) than the lower-potassium groups.

### PERMANOVA equivalence to ANOVA

PERMANOVA works as 'regular' ANOVA when using Euclidean distances.  We'd expect a different _p_-value since we're using permutations, but identical _F_-values and sums-of-squares.

```{r grp-diff-equivalence, exercise=TRUE}
De <- dist(env$k, 'euc')            # Euclidean distances
adonis(De ~ env$grp, perm=999)      # examine F and SS
print(anova(lm(k ~ grp, env)))      # expect identical F and SS
```

### PERMANOVA for blocked design

For blocked designs (e.g., for repeated measures or genuine blocked designs), we must specify how permutations occur.  Because units are only exchangeable _within blocks_, the permutations should occur within blocks.

```{r grp-diff-blocked, exercise=TRUE}
### blocked design: permutations must occur within strata
blk <- factor(LETTERS[sample(rep(1:12,len=nrow(env)))]) # arbitrary 'blocks'
plot(m1)                                       # visualize on NMS
ordispider(m1, blk, label=TRUE)
customperm <- how(nperm=999)                   # set number of permutations
setBlocks(customperm) <- blk                   # permute only *within* blocks
adonis(D ~ env$grp, permutations=customperm)   # correct test
```

### Key references

Anderson, M. J., and D. C. I. Walsh. 2013. PERMANOVA, ANOSIM, and the Mantel test in the face of heterogeneous dispersions: What null hypothesis are you testing? *Ecological Monographs* 83:557–574. https://doi.org/10.1890/12-2010.1


<!-- --------------------------------------------- -->


## Group indicator species

#### *Which species are indicative of pre-defined groups?*

The Indicator Value (_IndVal_) is the product of a species' fidelity and specificity to a group (Dufrêne and Legendre 1997).

Here we use `labdsv::indval` to examine indicators of _single_ groups, but also see R package `indicspecies` to test whether species might indicate _multiple_ groups.

First, let's use the same groups we used for PERMANOVA: which species are indicative of the four groups defined by soil potassium?  We can compare these "real" indicator species against a random expectation.

```{r indval, exercise=TRUE}
### real groups
grp <- cut(env$k, quantile(env$k, probs=seq(0,1,by=0.25)), include.lowest=T,
               labels=c('lo','med','hi','veryhi'))   # group memberships
iv  <- labdsv::indval(spe, grp) # indicator species analysis for *real* groups
summary(iv)                     # IndVal observed

### random groups
rnd <- sample(grp, length(grp), replace=T) # define random groups by bootstrapping
ivr <- labdsv::indval(spe, rnd) # indicator species analysis for *random* groups
summary(ivr)                    # IndVal expected at random
```

How many indicator species would you expect at random?

```{r indval-null}
### null expectation setting alpha = 5%
ceiling( ncol(spe) * 0.05 )

```

If you defined groups by a clustering method using species information, do not use _IndVal_ to find indicator species of those groups (that would be circular logic).  


### Key references

Dufrêne, M. and Legendre, P. 1997. Species assemblages and indicator species: the need for a flexible asymmetrical approach. _Ecological Monographs_ 67(3): 345--366.  

<!-- --------------------------------------------- -->


## Community traits

Recall the traits matrix, which assigns each species (rows) a value for each of twelve traits (columns):

```{r peek-traits, exercise=T}
head(tra)
```

We can ask several questions about trait diversity, convergence/divergence, and relationships to environment.

#### *How do traits relate to environment?*


#### *Are traits (of species in a site) convergent or divergent?*

The mean pairwise distance (MPD) shows how far (on average) the traits of one community are relative to all others.  Most commonly these are Euclidean or Gower distances.  A randomization test gives a test statistic called SES, standardized effect size.  Significant positive SES indicates traits are less similar than expected at random (i.e., species have divergent traits), while negative SES indicates traits are more similar than expected at random (i.e., species tend to converge on similar traits). We can examine trait divergence/convergence along a gradient, or test for divergence/convergence within groups.

```{r trait-converge, exercise=TRUE}
### Euclidean trait distance (traits already scaled 0-1)
Dt  <- dist(tra, method='euc')
### calculate trait SES of mean pairwise distances in sites
ses <- picante::ses.mpd(spe, Dt, null.model='richness', abund=F, runs=999)
### plot SES across the gradient
plot(ses$mpd.obs.z ~ env$k, ylab='Trait SES(MPD)', xlab='Soil potassium', 
     col=ifelse(ses$mpd.obs.p < 0.05, 'red','black'))
abline(lm(ses$mpd.obs.z ~ env$k)) # regression line
abline(h=0, lty=2)                # random-traits line
text(0.9, 1, 'Divergent')      
text(0.9, -4, 'Convergent')
```

### Make a community-weighted means matrix

The result is a traits-by-site matrix.

```{r cwm, exercise=TRUE}
`makecwm` <- function (spe, tra) {
  spe <- as.matrix(spe)
  tra <- as.matrix(tra)
  `standardize` <- function(x) {
    (x - min(x, na.rm=TRUE)) / diff(range(x, na.rm=TRUE))
  }
  tra <- apply(tra, MARGIN = 2, FUN = standardize)
  awt <- spe %*% tra             # abundance-weighted trait totals
  awt / rowSums(spe, na.rm=TRUE) # community-weighted traits matrix
}
```

### Key references


<!-- --------------------------------------------- -->


## Community phylogenetics

#### *How do species' evolutionary relationships explain responses?*

### Plot phylogenies

```{r phylo-plot, exercise=TRUE}

### basic plotting
phy                   # basic structure
plot(phy, cex=0.75)   # basic plotting

### color tip labels by trait values
plot(phy, cex=0.75, tip.color=colvec(tra$lfp))
axisPhylo(cex=0.6)    # and add axis

### overlay trait values at tips
plot(phy, cex=0.75, label.offset = 12)
tiplabels(pch = 21, bg = c(tra$annual), adj = 2)
tiplabels(pch = 21, bg = c(tra$biennial), adj = 6)
tiplabels(pch = 21, bg = c(tra$perennial), adj = 10)

```


### Phylogenetic signal

```{r phylo-signal, exercise=TRUE}
### detect phylogenetic signal for traits
K <- sapply(tra, FUN=function(j){
  names(j) <- rownames(tra)
  round(picante::phylosignal(j, ape::multi2di(phy)),6)})
as.matrix(K) # Blomberg's K statistic for continuous traits
```

### Community phylogenetic analysis


### Key references


<!-- --------------------------------------------- -->


## Community spatial analysis

_*To what degree are communities structured spatially?*_  

_*How much variation is explained by space, environment, or spatially structured environment?*_

### Mantel test

The Mantel test compares a community dissimilarity matrix to a spatial distance matrix (it can also be used to compare any two dissimilarity matrices, for example, to test goodness-of-fit of Euclidean ordination distances to original community dissimilarities, or two ordination configurations).

Here we ask, is compositional dissimilarity related to spatial distances?

```{r mantel-orig, exercise=TRUE}
E <- dist(xy)                            # spatial distance matrix
vegan::mantel(D, euc, method='spearman')   # spearman *rank* correlation
# in `ecodist` package, we also get useful bootstrap CIs:
ecodist::mantel(D ~ euc, mrank=T)          # spearman *rank* correlation
```

A Mantel correlogram depicts this correlation of compositional dissimilarity at specified lag distances.

```{r mantel-correlogram, exercise=TRUE}
brk <- seq(0, round(max(euc),-1), by=10)
plot(ecodist::mgram(D, euc, breaks=brk, nperm=99, mrank=T, nboot=500))
abline(h=0, col='red')
plot(vegan::mantel.correlog(D, euc, break.pts=brk, cutoff=F, r.type='spearman',
                            nperm=99, mult='holm', progressive=T))
```

### MRM: multiple regression on distance matrices

MRM: multiple regression on distance matrices.

```{r mrm, exercise=TRUE}
# species dissimilarities are related to space (extremely weakly) and 
#   potassium (moderately)
ecodist::MRM(D ~ dist(xy) + dist(env$k), nperm=999) 

# abundance of cosmopolitan bulrush is NOT related to space, 
#   but is related to potassium (moderately)
ecodist::MRM(dist(spe$bolboschoenus_maritimus) ~ dist(xy) + dist(env$k), nperm=999) 

```

### PCNM: principle coordinates of neighbor matrices.

We can quantify spatial distances among sites with a Euclidean distance matrix. Performing principal coordinates analysis on this "neighbor matrix" gives us PCNMs: principle coordinates of neighbor matrices.  PCNM scores are interpreted as *orthogonal* explanatory variables at varying spatial scales: think of them as progressively broad-, medium- and local-scale predictors.

```{r pcnm-mapping, exercise=TRUE, fig.asp=0.555}
E   <- dist(xy)                    # euclidean distances between sites
pc  <- pcnm(euc)                   # principal coordinates of neighbor matrices
par(mfrow=c(2,3), oma=c(0,0,0,0), mar=c(2,2,2,0)) # map PCNMs across study area
v   <- 2^(0:5)                     # select PCNMs at increasingly fine scale
for(i in seq_along(v)) {
  ordisurf(xy, scores(pc, choices=v[i]), bubble=3, main=paste0('PCNM ',v[i]))
}
```

We can use *weighted* principle coordinates of neighbor matrices as explanatory variables in CCA to construct a multiscale ordination (MSO) variogram.  Residual variance here would indicate spatial autocorrelation; we hope for this to exhibit no trend with distance, since PCNMs account for spatial autocorrelation.

```{r pcnm-mso, exercise=TRUE}
E     <- dist(xy)                 # euclidean distances between sites
rs    <- rowSums(spe) / sum(spe)  # sites weighted by abundances 
pc    <- pcnm(E, w=rs)            # *weighted* PCNMs
ord   <- cca(spe ~ scores(pc))    # CCA: species constrained by space
msord <- mso(ord, xy)             # multiscale ordination
msoplot(msord, expl=T)            # MSO variogram: spatial trend in residuals?
```

Using the weighted PCNMs above, we can perform variance partitioning of species dissimilarities in dbRDA (distance-based RDA).  This particular variation partitioning shows the amount of variation in species dissimilarities (**D**) explained by 1) space, 2) environment, and 3) spatially-structured environment.

```{r pcnm-varpart-01, exercise=TRUE, exercise.setup='pcnm-mso'}
(vp <- varpart(D, env, scores(pc))) 
plot(vp, bg = c(2,4))
text(-0.2, 0.3, 'Environment', cex=0.7)
text(0.5, 0.3, 'Spatially-\nstructured\nenviro', cex=0.7)
text(1.2, 0.3, 'Space', cex=0.7)
```

We can include more explanatory matrices -- here, species dissimilarities explained by 1) environment, 2) broad spatial, and 3) local spatial.

```{r pcnm-varpart-02, exercise=TRUE, exercise.setup='pcnm-mso'}
pc_broad <- scores(pc)[,1:10]
pc_local <- scores(pc)[,11:59]
(vp <- varpart(D, env, pc_broad, pc_local)) 
plot(vp, cex=0.7, bg=2:5) 
text(-0.2, 0.3, 'Environment', cex=0.7)
text(0.5, 0.55, 'Broad-\nstructured\nenviro', cex=0.7)
text(1.2, 0.3, 'Broad\nspatial', cex=0.7)
text(-0.5, -0.75, 'Local-\nstructured\nenviro', cex=0.7)
text(0.5, -1.15, 'Local\nspatial', cex=0.7)
### Thinker: why do "broad" and "local" share in common zero variance explained?
```

We can include more explanatory matrices -- here, species dissimilarities explained by 1) soil fractions, 2) soil chemistry, and 3) spatial processes.

```{r pcnm-varpart-03, exercise=TRUE, exercise.setup='pcnm-mso'}
(vp <- varpart(D,                               # dissimilarities
               ~ clay + sand + silt,            # soil fractions
               ~ mg + k + conductivity + na_l,  # soil chemistry
               scores(pc),                      # spatial predictors
               data=env))
plot(vp, cex=0.7, bg=2:5)
text(-0.2, 0.3, 'Soil fractions', cex=0.7)
text(1.2, 0.3, 'Soil chemistry', cex=0.7)
text(0.5, -1.15, 'Spatial', cex=0.7)
text(-0.5, -0.75, 'Spatially-\nstructured\nsoil fractions', cex=0.7)
text(1.5, -0.75, 'Spatially-\nstructured\nsoil chemistry', cex=0.7)
### Thinker: how do you interpret this figure?  
### Moderate spatial structuring, a bit owing to soil chemistry,
### but mostly to other unmeasured spatial processes (dispersal?).

### Thinker: what does this NOT explain?  
### What is the biological cause of residual variation?
### We did ordination in 1) species space, 2) env space, 
###   3) env constrained spp space?
```


### SYNCSA



### Key references

Borcard D. and Legendre P. 2002. All-scale spatial analysis of ecological data by means of principal coordinates of neighbour matrices. _Ecological Modelling_ 153: 51-68.

Dray, S., R. Pélissier, P. Couteron, M.-J. Fortin, P. Legendre, P. R. Peres-Neto, E. Bellier, R. Bivand, F. G. Blanchet, M. De Cáceres, A.-B. Dufour, E. Heegaard, T. Jombart, F. Munoz, J. Oksanen, J. Thioulouse, and H. H. Wagner. 2012. Community ecology in the age of multivariate multiscale spatial analysis. _Ecological Monographs_ 82: 257-275.

Lichstein, J. 2007. Multiple regression on distance matrices: a multivariate spatial analysis tool. _Plant Ecology_ 188:117-131.

Mantel, N. 1967. The detection of disease clustering and a generalized regression approach. _Cancer Research_ 27:209-220.

McArdle, B.H. & Anderson, M.J. 2001. Fitting multivariate models to community data: a comment on distance-based redundancy analysis. _Ecology_ 82: 290-297.

Wagner, H.H. 2004. Direct multi-scale ordination with canonical correspondence analysis. _Ecology_ 85: 342-351.


<!-- --------------------------------------------- -->


## Appendix 1: Workflow example

### Best practices (opinionated)

This common workflow uses common practices in ecological community analysis.  It is by no means universal or obligatory!

**Data I/O:** read data into R (typically `read.csv` if CSV files).

**Basic exploration:** use basic commands to examine data structure (`str`), peek at data (`head`), see the frequency distribution (`hist`), make biplots (`plot` or `pairs`).

**Advanced exploration:** `vegan::tabasco` or `labdsv::`

**Transformations:** log10+1 for abundances, row-standardize abundances to put sites on equal footing, range standardize for enviro or traits(so all on same scale) -- McCune

**Outliers:**

**Community dissimilarities:** Bray-Curtis -- Legendre and Legendre 2012

**Environmental distances:** (scaled) Euclidean

**Dissimilarity adjustments:** step-across shortest distance if high beta-diversity -- Smith

**Ordination of sites, based on communities:** NMS -- Minchin

**Ordination of sites, based on environment:** PCA -- linear combinations

**Ordination of sites, based on communities constrained by environment:** dbRDA or FSO

**Comparing ordination configurations:** Procrustes -- Peres-Neto

**Clustering:** optpart or or fuzzy clustering or Wards -- Roberts

**Group differences:** PERMANOVA --Anderson

**Group indicator species:** IndVal -- Dufrene and Legendre






<!-- --------------------------------------------- -->


## Appendix 2: Further resources

#### General R usage

[R for Data Science](https://r4ds.had.co.nz/)  

[Data Carpentry](https://datacarpentry.org/R-ecology-lesson/index.html)  

#### Ecology in R

[Dave Roberts' labdsv pages](http://ecology.msu.montana.edu/labdsv/R/)  

[Jari Oksanen's vegan introduction - PDF](https://cran.r-project.org/web/packages/vegan/vignettes/intro-vegan.pdf)  

[David Zelený's community analysis](http://www.davidzeleny.net/anadat-r/doku.php?id=en:start)  

[Tad Fukami's ecological statistics](https://fukamilab.github.io/BIO202/)  

[Steve Kembel traits and phylogenies tutorial](http://www.kembellab.ca/r-workshop/biodivR/SK_Biodiversity_R.html)

#### Community analysis R packages

[CRAN Environmetrics Task View](https://cran.r-project.org/web/views/Environmetrics.html)  
[vegan](https://cran.r-project.org/web/packages/vegan/index.html)  
[labdsv](https://cran.r-project.org/web/packages/labdsv/index.html)  
[optpart](https://cran.r-project.org/web/packages/optpart/index.html)  
[ade4](https://cran.r-project.org/web/packages/ade4/index.html)  
[ecodist](https://cran.r-project.org/web/packages/ecodist/index.html)  


<!-- --------------------------------------------- -->


## Appendix 3: FAQ

[Why are we here today?](#why-here)

[Where did this dataset originate? How do I use it?](#data-origin)

etc


<!-- <!-- --------------------------------------------- --> -->


<!-- ## Direct gradient analysis -->

<!-- #### *How does this species (or trait, or ...) relate to an environmental gradient?* -->

<!-- ```{r direct-gradient-analysis, exercise=TRUE} -->
<!-- # prepare vector data -->
<!-- y <- rowSums((spe > 0) * 1)  # response vector = species richness -->
<!-- x <- env[,'k']               # predictor vector = potassium concentration -->

<!-- # fit two models -->
<!-- mod_linear    <- stats::lm(y ~ x)                # simple linear model -->
<!-- mod_nonlinear <- mgcv::gam(y ~ s(x), gamma=0.25) # nonlinear GAM model -->

<!-- # view model summaries -->
<!-- summary(mod_linear) -->
<!-- summary(mod_nonlinear) -->

<!-- # visualize fitted values -->
<!-- plot(x, y, xlab='Potassium', ylab='Richness', pch=16, col='#00000050') -->
<!-- xs <- seq(min(x), max(x), len = 99) -->
<!-- lines(xs, predict(mod_linear, data.frame(x = xs)), lwd = 2, col='darkblue') -->
<!-- lines(xs, predict(mod_nonlinear, data.frame(x = xs)), lwd = 2, col='orange') -->

<!-- # LETS PREDICT onto a landscape grid (raster) -->
<!-- # first, simulate data with spatial pattern (negative exponential decay) -->
<!-- `simulate_grid` <- function(nr = 49, seed = 2021, ...) { -->
<!--   g <- expand.grid(lon=seq(0,1,len=nr),lat=seq(0,1,len=nr)) # all combos -->
<!--   `f` <- function(n, mu = 0, V = matrix(1)) { # multivariate normal sampling -->
<!--     p <- length(mu) -->
<!--     t(matrix(rnorm(n * p), ncol=p) %*% chol(V) + rep(mu, rep(n, p))) -->
<!--   } -->
<!--   set.seed(seed=seed) -->
<!--   k <- f(1, rep(3,nrow(g)), exp(-0.05 * as.matrix(dist(g)))) # do sampling -->
<!--   k <- decostand(scale(k, center=F), 'range')                # re-scale 0-1 -->
<!--   return(cbind(g,k)) # soil value at each lon/lat -->
<!-- } -->
<!-- nr <- 49 -->
<!-- g <- simulate_grid(nr) -->

<!-- # predict from the models -->
<!-- g$pr_lin <- predict(mod_linear, newdata=data.frame(x=g$k)) -->
<!-- g$pr_non <- predict(mod_nonlinear, newdata=data.frame(x=g$k)) -->

<!-- # plot the landscapes -->
<!-- u  <- c('#414487','#39558C','#30698E','#297A8E','#228B8D','#1E9C89', -->
<!--         '#26AD81','#40BD72','#65CB5E','#90D743','#BBDF27') # colors -->
<!-- par(mfrow=c(1,3)) -->
<!-- image(matrix(g$k, nrow=nr), col=u, main='patchy landscape\nof potassium') -->
<!-- image(matrix(g$pr_lin, nrow=nr), col=u, main='species richness,\nlinear') -->
<!-- image(matrix(g$pr_non, nrow=nr), col=u, main='species richness,\nnonlinear') -->
<!-- ``` -->






<!-- ### Best subset of environmental predictors -->

<!-- Which environmental predictors are most related to community compositions?  We can find this by maximizing the rank correlation between environmental distances and community dissimilarities, using the BIOENV procedure. -->

<!-- ```{r best-bioenv, exercise=TRUE} -->
<!-- best <- bioenv(D, env=env[,sapply(env, is.numeric)], upto=3, trace=T) -->
<!-- best -->
<!-- ``` -->



